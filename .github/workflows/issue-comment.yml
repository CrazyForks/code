name: Issue Comment (Preview)

on:
  # Automatic: when Preview Build finishes successfully for a PR
  workflow_run:
    workflows: ["Preview Build"]
    types: [completed]
  # Manual: allow maintainers to trigger for a specific PR
  workflow_dispatch:
    inputs:
      pr_number:
        description: "PR number to post preview comment to linked issue"
        required: true
        type: number

concurrency:
  group: issue-comment-${{ github.event_name == 'workflow_dispatch' && inputs.pr_number || github.event.workflow_run.id }}
  cancel-in-progress: true

permissions:
  contents: read
  issues: write
  pull-requests: read
  actions: read

jobs:
  comment:
    name: Post preview instructions to linked issue
    if: >-
      (github.event_name == 'workflow_run' &&
       github.event.workflow_run.event == 'pull_request' &&
       github.event.workflow_run.conclusion == 'success')
      || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest

    steps:
      - name: Resolve PR + Issue
        id: meta
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Determine PR number from workflow_run payload or manual input
            let prNumber = 0;
            if (context.eventName === 'workflow_run') {
              const wr = context.payload.workflow_run;
              const prs = Array.isArray(wr.pull_requests) ? wr.pull_requests : [];
              if (prs.length) prNumber = prs[0].number;
            } else {
              prNumber = Number((context.payload.inputs && context.payload.inputs.pr_number) || 0);
            }
            if (!prNumber) {
              core.setFailed('Unable to resolve PR number.');
              return;
            }

            // Fetch PR details
            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });

            // Try to derive issue number from head branch (issue-123), PR body/title references, or linked issues
            let issueNumber = 0;
            const branch = pr.head.ref || '';
            const m = branch.match(/^issue-(\d+)$/);
            if (m) issueNumber = Number(m[1]);

            function findIssueRef(text) {
              if (!text) return 0;
              // Prefer explicit forms like "Closes #123" or "#123"
              const rx = /(close[sd]?|fix(e[sd])?|resolve[sd]?)?\s*#(\d{1,6})/ig;
              let best = 0; let mm;
              while ((mm = rx.exec(text))) { best = Number(mm[3]); }
              return best;
            }
            if (!issueNumber) issueNumber = findIssueRef(pr.body);
            if (!issueNumber) issueNumber = findIssueRef(pr.title);

            // Quick fallback: search issues mentioning the PR number (rarely needed)
            if (!issueNumber) {
              try {
                const q = `repo:${owner}/${repo} is:issue ${pr.number}`;
                const s = await github.rest.search.issuesAndPullRequests({ q, per_page: 5 });
                const hit = s.data.items.find(i => i.pull_request == null);
                if (hit) issueNumber = hit.number;
              } catch {}
            }

            // Collect a compact file summary for context
            const files = await github.paginate(github.rest.pulls.listFiles, { owner, repo, pull_number: prNumber, per_page: 100 });
            const changed = files.map(f => `- ${f.status.padEnd(6)} ${f.filename}`).slice(0, 50);

            // Collect latest commit subjects on the PR (brief)
            let commits = [];
            try {
              const all = await github.paginate(github.rest.pulls.listCommits, { owner, repo, pull_number: prNumber, per_page: 100 });
              commits = all.slice(-5).map(c => `- ${c.commit.message.split('\n')[0]}`);
            } catch {}

            core.setOutput('pr_number', String(prNumber));
            core.setOutput('issue_number', String(issueNumber || 0));
            core.setOutput('title', pr.title || '');
            core.setOutput('body', pr.body || '');
            core.setOutput('head', pr.head.ref || '');
            core.setOutput('base', pr.base.ref || '');
            core.setOutput('changed', changed.join('\n'));
            core.setOutput('commits', commits.join('\n'));

      - name: Prepare context file
        id: ctx
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ steps.meta.outputs.pr_number }}
          TITLE: ${{ steps.meta.outputs.title }}
          BODY: ${{ steps.meta.outputs.body }}
          CHANGED: ${{ steps.meta.outputs.changed }}
          COMMITS: ${{ steps.meta.outputs.commits }}
        with:
          script: |
            const fs = require('fs');
            const owner = context.repo.owner; const repo = context.repo.repo;
            const pr = Number(process.env.PR_NUMBER);
            // resolve slug
            const { data: pull } = await github.rest.pulls.get({ owner, repo, pull_number: pr });
            const marker = /<!--\s*codex-id:\s*([a-z0-9-]{3,})\s*-->/i;
            let slug = '';
            const m = (pull.body || '').match(marker);
            if (m) slug = m[1].toLowerCase();
            if (!slug) {
              const b = pull.head.ref || '';
              const im = b.match(/^issue-(\d+)$/); let issue_number = 0; if (im) issue_number = Number(im[1]);
              if (issue_number) {
                const comments = await github.paginate(github.rest.issues.listComments, { owner, repo, issue_number, per_page: 100 });
                for (const c of comments) { const mm = (c.body || '').match(marker); if (mm) { slug = mm[1].toLowerCase(); break; } }
              }
            }
            if (!slug) throw new Error('Missing codex-id marker on PR/issue.');
            // resolve latest tag for slug
            const baseTag = `preview-${slug}`;
            const rels = await github.paginate(github.rest.repos.listReleases, { owner, repo, per_page: 100 });
            let tag = baseTag; let maxN = 0; let hasBase = false;
            for (const r of rels) {
              const t = r.tag_name || '';
              if (t === baseTag) { hasBase = true; maxN = Math.max(maxN, 1); tag = baseTag; }
              const mm = t.match(new RegExp(`^${baseTag}-(\\d+)$`));
              if (mm) { const n = parseInt(mm[1], 10); if (n > maxN) { maxN = n; tag = t; } }
            }
            const releaseBase = `https://github.com/${owner}/${repo}/releases/download/${tag}`;
            const dl = [
              `- Linux x86_64 (.zst): ${releaseBase}/code-x86_64-unknown-linux-musl.zst`,
              `- Linux x86_64 (.tar.gz): ${releaseBase}/code-x86_64-unknown-linux-musl.tar.gz`,
              `- Linux aarch64 (.zst): ${releaseBase}/code-aarch64-unknown-linux-musl.zst`,
              `- Linux aarch64 (.tar.gz): ${releaseBase}/code-aarch64-unknown-linux-musl.tar.gz`,
              `- macOS x86_64 (.zst): ${releaseBase}/code-x86_64-apple-darwin.zst`,
              `- macOS x86_64 (.tar.gz): ${releaseBase}/code-x86_64-apple-darwin.tar.gz`,
              `- macOS arm64 (.zst): ${releaseBase}/code-aarch64-apple-darwin.zst`,
              `- macOS arm64 (.tar.gz): ${releaseBase}/code-aarch64-apple-darwin.tar.gz`,
              `- Windows x86_64 (.zip): ${releaseBase}/code-x86_64-pc-windows-msvc.exe.zip`,
            ].join('\n');
            const lines = [];
            lines.push(`# PR #${pr}: ${process.env.TITLE || ''}`);
            lines.push('');
            if ((process.env.BODY || '').trim()) {
              lines.push('## PR body');
              lines.push(process.env.BODY.trim());
              lines.push('');
            }
            if ((process.env.CHANGED || '').trim()) {
              lines.push('## Changed files (first 50)');
              lines.push(process.env.CHANGED.trim());
              lines.push('');
            }
            if ((process.env.COMMITS || '').trim()) {
              lines.push('## What changed in this build (recent commits)');
              lines.push(process.env.COMMITS.trim());
              lines.push('');
            }
            lines.push('## Preview command');
            lines.push('```bash');
            lines.push(`code preview ${slug}`);
            lines.push('```');
            lines.push('');
            lines.push('## Direct downloads');
            lines.push(dl);
            fs.mkdirSync('.github/auto', { recursive: true });
            fs.writeFileSync('.github/auto/ISSUE_PREVIEW_CONTEXT.md', lines.join('\n'));

      - name: Start local OpenAI proxy (optional)
        if: env.OPENAI_API_KEY != ''
        id: proxy
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set -euo pipefail
          cat > .github/auto/openai-proxy.js <<'JS'
          const http = require('http');
          const https = require('https');
          const { URL } = require('url');
          const PORT = process.env.PORT || 5056;
          const API_KEY = process.env.OPENAI_API_KEY || '';
          const ALLOWED = ['/v1/chat/completions','/v1/responses'];
          if (!API_KEY) { process.exit(0); }
          const server = http.createServer((req, res) => {
            if (req.method !== 'POST' || !ALLOWED.some(p => req.url.startsWith(p))) {
              res.writeHead(403, { 'content-type': 'application/json' });
              res.end(JSON.stringify({ error: 'blocked' }));
              return;
            }
            const chunks = [];
            req.on('data', c => { chunks.push(c); if (Buffer.concat(chunks).length > 1024*1024) req.destroy(); });
            req.on('end', () => {
              const up = new URL('https://api.openai.com' + req.url);
              const fw = https.request({ method: 'POST', hostname: up.hostname, path: up.pathname + up.search, headers: { 'content-type': 'application/json', 'authorization': `Bearer ${API_KEY}` } }, r => { res.writeHead(r.statusCode || 500, r.headers); r.pipe(res); });
              fw.on('error', e => { res.writeHead(502, {'content-type':'application/json'}); res.end(JSON.stringify({ error:'upstream', message: e.message })); });
              fw.end(Buffer.concat(chunks));
            });
          });
          server.listen(PORT, '127.0.0.1', () => { console.log('proxy listening on 127.0.0.1:'+PORT); });
          JS
          node .github/auto/openai-proxy.js > .github/auto/openai-proxy.log 2>&1 &

      - name: Generate comment with Code (read-only)
        id: gen
        continue-on-error: true
        run: |
          set -euo pipefail
          SAFE_PATH="$PATH"; SAFE_HOME="$HOME";
          PROMPT=$(cat <<'EOP'
          <task>
          Write a concise, friendly issue comment that:
          - Explains what PR below does in 2–4 bullets (user-facing impact only).
          - Tells the reporter how to run the preview (include the exact command block provided).
          - Includes the direct download links section.
          Keep it short and actionable. Do not include CI or maintainer-only details.
          </task>
          <context>
          $(cat .github/auto/ISSUE_PREVIEW_CONTEXT.md)
          </context>
          Output ONLY:
          <comment>
          …final Markdown comment…
          </comment>
          EOP
          )
          set +e
          { printf '%s' "$PROMPT" | env -i PATH="$SAFE_PATH" HOME="$SAFE_HOME" \
              OPENAI_API_KEY="x" OPENAI_BASE_URL="http://127.0.0.1:5056/v1" \
              npx -y @just-every/code@latest exec -s read-only --cd "$GITHUB_WORKSPACE" --skip-git-repo-check -; } \
            2>&1 | tee .github/auto/AGENT_OUT.txt
          true
          set -e
          node - <<'JS'
          const fs = require('fs');
          const t = fs.readFileSync('.github/auto/AGENT_OUT.txt','utf8');
          const m = t.match(/<comment>([\s\S]*?)<\/comment>/i);
          if (m && m[1].trim()) {
            fs.writeFileSync('.github/auto/ISSUE_COMMENT.md', m[1].trim() + '\n');
          }
          JS

      - name: Post comment to linked issue (upsert by marker; fallback to stock)
        uses: actions/github-script@v7
        env:
          ISSUE_NUMBER: ${{ steps.meta.outputs.issue_number }}
          PR_NUMBER: ${{ steps.meta.outputs.pr_number }}
        with:
          script: |
            const fs = require('fs');
            const owner = context.repo.owner; const repo = context.repo.repo;
            const issue_number = Number(process.env.ISSUE_NUMBER || 0);
            const pr = Number(process.env.PR_NUMBER || 0);
            if (!issue_number) { core.notice('No linked issue detected; skipping issue comment.'); return; }
            const ISSUE_MARK = '<!-- preview-build:issue -->';
            let body = '';
            try { body = fs.readFileSync('.github/auto/ISSUE_COMMENT.md','utf8').trim(); } catch {}
            const PLACEHOLDER = '…final Markdown comment…';
            if (body && body.includes(PLACEHOLDER)) { body = ''; }
            if (!body) {
              // derive slug + latest tag
              const { data: pull } = await github.rest.pulls.get({ owner, repo, pull_number: pr });
              const slugRe = /<!--\s*codex-id:\s*([a-z0-9-]{3,})\s*-->/i;
              let slug = '';
              const m = (pull.body || '').match(slugRe);
              if (m) slug = m[1].toLowerCase();
              if (!slug) {
                const b = pull.head.ref || '';
                const im = b.match(/^issue-(\d+)$/); let issue_number2 = 0; if (im) issue_number2 = Number(im[1]);
                if (issue_number2) {
                  const comments = await github.paginate(github.rest.issues.listComments, { owner, repo, issue_number: issue_number2, per_page: 100 });
                  for (const c of comments) { const mm = (c.body || '').match(slugRe); if (mm) { slug = mm[1].toLowerCase(); break; } }
                }
              }
              const baseTag = `preview-${slug}`;
              const rels = await github.paginate(github.rest.repos.listReleases, { owner, repo, per_page: 100 });
              let tag = baseTag; let maxN = 0; let hasBase = false;
              for (const r of rels) {
                const t = r.tag_name || '';
                if (t === baseTag) { hasBase = true; maxN = Math.max(maxN, 1); tag = baseTag; }
                const mm = t.match(new RegExp(`^${baseTag}-(\\d+)$`));
                if (mm) { const n = parseInt(mm[1], 10); if (n > maxN) { maxN = n; tag = t; } }
              }
              const base = `https://github.com/${owner}/${repo}/releases/download/${tag}`;
              body = [
                ISSUE_MARK,
                '### Preview Build',
                '',
                'You can run this right now! In your terminal just use:',
                '```bash',
                `code preview ${slug}`,
                '```',
                'This will run the version of Code we\'ve created for this issue.',
                '',
                'Direct downloads:',
                `- Linux x86_64 (.zst): ${base}/code-x86_64-unknown-linux-musl.zst`,
                `- Linux x86_64 (.tar.gz): ${base}/code-x86_64-unknown-linux-musl.tar.gz`,
                `- Linux aarch64 (.zst): ${base}/code-aarch64-unknown-linux-musl.zst`,
                `- Linux aarch64 (.tar.gz): ${base}/code-aarch64-unknown-linux-musl.tar.gz`,
                `- macOS x86_64 (.zst): ${base}/code-x86_64-apple-darwin.zst`,
                `- macOS x86_64 (.tar.gz): ${base}/code-x86_64-apple-darwin.tar.gz`,
                `- macOS arm64 (.zst): ${base}/code-aarch64-apple-darwin.zst`,
                `- macOS arm64 (.tar.gz): ${base}/code-aarch64-apple-darwin.tar.gz`,
                `- Windows x86_64 (.zip): ${base}/code-x86_64-pc-windows-msvc.exe.zip`,
                ISSUE_MARK
              ].join('\n');
            }
            // Upsert by marker on the issue
            const all = await github.paginate(github.rest.issues.listComments, { owner, repo, issue_number, per_page: 100 });
            const mine = all.find(c => c.user?.type?.toLowerCase().includes('bot') && (c.body || '').includes(ISSUE_MARK));
            if (mine) {
              await github.rest.issues.updateComment({ owner, repo, comment_id: mine.id, body });
            } else {
              await github.rest.issues.createComment({ owner, repo, issue_number, body });
            }
