name: Upstream Merge

on:
  # Poll upstream regularly; also allow manual and external triggers
  schedule:
    - cron: '*/30 * * * *'
  workflow_dispatch:
    inputs:
      upstream_repo:
        description: 'Upstream repo (owner/name)'
        required: false
        default: 'openai/codex'
      upstream_branch:
        description: 'Upstream branch'
        required: false
        default: 'main'
  repository_dispatch:
    types: [upstream-push]

concurrency:
  group: upstream-merge
  cancel-in-progress: true

permissions:
  contents: write
  pull-requests: write

env:
  UPSTREAM_REPO: ${{ inputs.upstream_repo || 'openai/codex' }}
  UPSTREAM_BRANCH: ${{ inputs.upstream_branch || 'main' }}
  MERGE_BRANCH: upstream-merge

jobs:
  merge:
    runs-on: ubuntu-latest
    timeout-minutes: 45

    steps:
      - name: Check out repository (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Configure authenticated origin for pushes
        env:
          GH_TOKEN: ${{ secrets.CODE_GH_PAT || github.token }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          git remote set-url origin "https://x-access-token:${GH_TOKEN}@github.com/${REPO}.git"

      - name: Setup Rust toolchain (match repo)
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.89.0

      - name: Install tools (ripgrep)
        run: |
          sudo apt-get update
          sudo apt-get install -y ripgrep

      - name: Cache Rust build (cargo + target)
        uses: Swatinem/rust-cache@v2
        with:
          # Our Rust workspace lives in codex-rs; cache its target dir
          workspaces: |
            codex-rs -> target
          save-if: true

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Cache npm (npx) downloads
        uses: actions/cache@v4
        with:
          path: |
            ~/.npm
          key: npm-cache-${{ runner.os }}-node20-${{ hashFiles('**/package-lock.json', '**/pnpm-lock.yaml', '**/yarn.lock') }}
          restore-keys: |
            npm-cache-${{ runner.os }}-node20-

      - name: Start local OpenAI proxy (no key to agent)
        id: openai_proxy
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set -euo pipefail
          if [ -z "${OPENAI_API_KEY:-}" ]; then
            echo "OPENAI_API_KEY secret is required to start the proxy." >&2
            exit 1
          fi
          mkdir -p .github/auto
          cat > .github/auto/openai-proxy.js <<'JS'
          const http = require('http');
          const https = require('https');
          const { URL } = require('url');
          const PORT = process.env.PORT || 5055;
          const API_KEY = process.env.OPENAI_API_KEY || '';
          const ALLOWED = ['/v1/chat/completions','/v1/responses'];
          if (!API_KEY) { console.error('OPENAI_API_KEY missing'); process.exit(1); }
          const server = http.createServer((req, res) => {
            if (req.method !== 'POST' || !ALLOWED.some(p => req.url.startsWith(p))) {
              res.writeHead(403, { 'content-type': 'application/json' });
              res.end(JSON.stringify({ error: 'blocked' }));
              return;
            }
            const chunks = [];
            req.on('data', c => { chunks.push(c); if (Buffer.concat(chunks).length > 1024*1024) req.destroy(); });
            req.on('end', () => {
              const up = new URL('https://api.openai.com' + req.url);
              const fw = https.request({
                method: 'POST',
                hostname: up.hostname,
                path: up.pathname + up.search,
                headers: { 'content-type': 'application/json', 'authorization': `Bearer ${API_KEY}` }
              }, r => { res.writeHead(r.statusCode || 500, r.headers); r.pipe(res); });
              fw.on('error', e => { res.writeHead(502, {'content-type':'application/json'}); res.end(JSON.stringify({ error:'upstream', message: e.message })); });
              fw.end(Buffer.concat(chunks));
            });
          });
          server.listen(PORT, '127.0.0.1', () => { console.log('proxy listening on 127.0.0.1:'+PORT); });
          JS
          node .github/auto/openai-proxy.js > .github/auto/openai-proxy.log 2>&1 &
          echo "pid=$!" >> "$GITHUB_OUTPUT"

      - name: Quick no-op check (skip if upstream/main already in origin)
        id: check_upstream
        shell: bash
        env:
          UPSTREAM_REPO: ${{ env.UPSTREAM_REPO }}
          UPSTREAM_BRANCH: ${{ env.UPSTREAM_BRANCH }}
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch || 'main' }}
        run: |
          set -euo pipefail
          git remote add upstream "https://github.com/${UPSTREAM_REPO}.git" 2>/dev/null || true
          git fetch origin --depth=1
          git fetch upstream --depth=1 "${UPSTREAM_BRANCH}"
          if git merge-base --is-ancestor "upstream/${UPSTREAM_BRANCH}" "origin/${DEFAULT_BRANCH}"; then
            echo "skip=true" >> "$GITHUB_OUTPUT"
            echo "No new upstream commits; skipping agent run."
          else
            echo "skip=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Run Code agent to perform upstream merge
        id: agent
        if: steps.check_upstream.outputs.skip != 'true'
        env:
          UPSTREAM_REPO: ${{ env.UPSTREAM_REPO }}
          UPSTREAM_BRANCH: ${{ env.UPSTREAM_BRANCH }}
          MERGE_BRANCH: ${{ env.MERGE_BRANCH }}
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch || 'main' }}
          GH_TOKEN: ${{ secrets.CODE_GH_PAT || github.token }}
          OURS_GLOBS: |
            codex-rs/tui/**
            codex-cli/**
            .github/workflows/**
            AGENTS.md
            README.md
            CHANGELOG.md
          THEIRS_GLOBS: |
            codex-rs/core/**
            codex-rs/common/**
            codex-rs/protocol/**
            codex-rs/exec/**
            codex-rs/file-search/**
        run: |
          set -euo pipefail
          SAFE_PATH="$PATH"; SAFE_HOME="$HOME"
          # Build the agent prompt safely without command substitution
          {
            printf 'Context\n- UPSTREAM_REPO=%s\n- UPSTREAM_BRANCH=%s\n- MERGE_BRANCH=%s\n- DEFAULT_BRANCH=%s\n\n' \
              "$UPSTREAM_REPO" "$UPSTREAM_BRANCH" "$MERGE_BRANCH" "$DEFAULT_BRANCH";
            cat << 'EOP'
          <task>
          You are the maintainer bot. Perform an upstream merge using our repo policies and a selective reconciliation strategy.
          Steps:
          1) Configure git with author "just-every-code <just-every-code@users.noreply.github.com>".
          2) Ensure remote `upstream` points to the UPSTREAM_REPO in Context. Fetch origin and upstream.
          3) Re-create branch MERGE_BRANCH from origin/DEFAULT_BRANCH.
          4) Merge upstream/UPSTREAM_BRANCH using `--no-commit`.
             - For files matching OURS_GLOBS: keep ours; if upstream added new files under these globs, remove them.
             - For files matching THEIRS_GLOBS: prefer theirs.
             - For everything else, default to ours unless the change is a clear, trivial improvement (typos/docs) that doesnâ€™t conflict with our direction.
          5) Stage and commit with a conventional message and short build status.
          6) Run ./build-fast.sh (warnings treated as failures). Apply minimal safe fixes only.
          7) Write MERGE_REPORT.md (Incorporated / Dropped / Other changes) summarizing choices.
          8) Push MERGE_BRANCH and prepare PR title/body.
          </task>

          <constraints>
          - Be minimal and surgical; do not refactor.
          - Keep diffs focused on merge and required fixes. Do not recreate locally removed theming/UX files.
          - Never rewrite git history outside the merge branch.
          - Use only the provided GH_TOKEN for push; do not echo it.
          </constraints>
          EOP
          } | env -i PATH="$SAFE_PATH" HOME="$SAFE_HOME" \
            OPENAI_API_KEY="x" \
            OPENAI_BASE_URL="http://127.0.0.1:5055/v1" \
            OPENAI_API_BASE="http://127.0.0.1:5055/v1" \
            GH_TOKEN="$GH_TOKEN" \
            npm_config_cache="$SAFE_HOME/.npm" \
            npx -y @just-every/code@latest \
            exec \
            -s workspace-write \
            -c sandbox_workspace_write.allow_git_writes=true \
            -c sandbox_workspace_write.network_access=true \
            -c shell_environment_policy.r#set.CARGO_HOME="${GITHUB_WORKSPACE}/.cargo-home" \
            -c shell_environment_policy.r#set.CARGO_TARGET_DIR="${GITHUB_WORKSPACE}/codex-rs/target" \
            --cd "$GITHUB_WORKSPACE" \
            --skip-git-repo-check \
            - | tee .github/auto/AGENT_STDOUT.txt

      - name: Open or update PR (use agent-supplied title/body if present)
        uses: actions/github-script@v7
        env:
          MERGE_BRANCH: ${{ env.MERGE_BRANCH }}
          UPSTREAM_REPO: ${{ env.UPSTREAM_REPO }}
          UPSTREAM_BRANCH: ${{ env.UPSTREAM_BRANCH }}
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch || 'main' }}
        with:
          github-token: ${{ secrets.CODE_GH_PAT || github.token }}
          script: |
            const fs = require('fs');
            function readOrDefault(p, dflt) { try { const t = fs.readFileSync(p,'utf8').trim(); return t || dflt; } catch { return dflt; } }
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const head = process.env.MERGE_BRANCH;
            const base = process.env.DEFAULT_BRANCH;
            const dfltTitle = `Upstream merge: ${process.env.UPSTREAM_REPO}@${process.env.UPSTREAM_BRANCH} into ${base}`;
            const title = readOrDefault('.github/auto/PR_TITLE.txt', dfltTitle);
            let body = readOrDefault('.github/auto/PR_BODY.md', '');
            if (!body) {
              body = `This PR merges ${process.env.UPSTREAM_REPO}@${process.env.UPSTREAM_BRANCH} into ${base}.`;
            }
            // Ensure the branch exists on origin before creating/updating a PR.
            const ref = `heads/${head}`;
            try {
              await github.rest.git.getRef({ owner, repo, ref });
            } catch (e) {
              core.notice(`Branch '${head}' not found on origin; skipping PR creation.`);
              return;
            }
            const headRef = `${owner}:${head}`;
            const prs = await github.rest.pulls.list({ owner, repo, state: 'open', head: headRef });
            if (prs.data.length) {
              const pr = prs.data[0];
              await github.rest.pulls.update({ owner, repo, pull_number: pr.number, title, body });
              core.notice(`Updated PR #${pr.number}`);
            } else {
              const pr = await github.rest.pulls.create({ owner, repo, title, head: headRef, base, body });
              core.notice(`Created PR #${pr.data.number}`);
            }
