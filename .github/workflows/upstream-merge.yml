name: Upstream Merge

on:
  # Poll upstream regularly; also allow manual and external triggers
  schedule:
    - cron: '*/30 * * * *'
  workflow_dispatch:
    inputs:
      upstream_repo:
        description: 'Upstream repo (owner/name)'
        required: false
        default: 'openai/codex'
      upstream_branch:
        description: 'Upstream branch'
        required: false
        default: 'main'
  repository_dispatch:
    types: [upstream-push]

concurrency:
  group: upstream-merge
  cancel-in-progress: true

permissions:
  contents: write
  pull-requests: write

env:
  UPSTREAM_REPO: ${{ inputs.upstream_repo || 'openai/codex' }}
  UPSTREAM_BRANCH: ${{ inputs.upstream_branch || 'main' }}
  MERGE_BRANCH: upstream-merge

jobs:
  merge:
    runs-on: ubuntu-latest
    timeout-minutes: 45

    steps:
      - name: Check out repository (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Configure authenticated origin for pushes
        env:
          GH_TOKEN: ${{ secrets.CODE_GH_PAT || github.token }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          git remote set-url origin "https://x-access-token:${GH_TOKEN}@github.com/${REPO}.git"

      - name: Setup Rust toolchain (match repo)
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.89.0

      - name: Install tools (ripgrep + jq)
        run: |
          sudo apt-get update
          sudo apt-get install -y ripgrep jq

      - name: Cache Rust build (cargo + target)
        uses: Swatinem/rust-cache@v2
        with:
          # Our Rust workspace lives in codex-rs; cache its target dir
          workspaces: |
            codex-rs -> target
          save-if: true

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Cache npm (npx) downloads
        uses: actions/cache@v4
        with:
          path: |
            ~/.npm
          key: npm-cache-${{ runner.os }}-node20-${{ hashFiles('**/package-lock.json', '**/pnpm-lock.yaml', '**/yarn.lock') }}
          restore-keys: |
            npm-cache-${{ runner.os }}-node20-

      - name: Start local OpenAI proxy (no key to agent)
        id: openai_proxy
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set -euo pipefail
          if [ -z "${OPENAI_API_KEY:-}" ]; then
            echo "OPENAI_API_KEY secret is required to start the proxy." >&2
            exit 1
          fi
          mkdir -p .github/auto
          cat > .github/auto/openai-proxy.js <<'JS'
          const http = require('http');
          const https = require('https');
          const { URL } = require('url');
          const PORT = process.env.PORT || 5055;
          const API_KEY = process.env.OPENAI_API_KEY || '';
          const ALLOWED = ['/v1/chat/completions','/v1/responses'];
          if (!API_KEY) { console.error('OPENAI_API_KEY missing'); process.exit(1); }
          const server = http.createServer((req, res) => {
            if (req.method !== 'POST' || !ALLOWED.some(p => req.url.startsWith(p))) {
              res.writeHead(403, { 'content-type': 'application/json' });
              res.end(JSON.stringify({ error: 'blocked' }));
              return;
            }
            const chunks = [];
            req.on('data', c => { chunks.push(c); if (Buffer.concat(chunks).length > 1024*1024) req.destroy(); });
            req.on('end', () => {
              const up = new URL('https://api.openai.com' + req.url);
              const fw = https.request({
                method: 'POST',
                hostname: up.hostname,
                path: up.pathname + up.search,
                headers: { 'content-type': 'application/json', 'authorization': `Bearer ${API_KEY}` }
              }, r => { res.writeHead(r.statusCode || 500, r.headers); r.pipe(res); });
              fw.on('error', e => { res.writeHead(502, {'content-type':'application/json'}); res.end(JSON.stringify({ error:'upstream', message: e.message })); });
              fw.end(Buffer.concat(chunks));
            });
          });
          server.listen(PORT, '127.0.0.1', () => { console.log('proxy listening on 127.0.0.1:'+PORT); });
          JS
          node .github/auto/openai-proxy.js > .github/auto/openai-proxy.log 2>&1 &
          echo "pid=$!" >> "$GITHUB_OUTPUT"

      - name: Quick no-op check (skip if upstream/main already in origin)
        id: check_upstream
        shell: bash
        env:
          UPSTREAM_REPO: ${{ env.UPSTREAM_REPO }}
          UPSTREAM_BRANCH: ${{ env.UPSTREAM_BRANCH }}
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch || 'main' }}
        run: |
          set -euo pipefail
          git remote add upstream "https://github.com/${UPSTREAM_REPO}.git" 2>/dev/null || true
          git fetch origin --depth=1
          git fetch upstream --depth=1 "${UPSTREAM_BRANCH}"
          # Extra short-circuit: if origin/upstream-merge already contains both
          # current tips (upstream and default), there is nothing new to do.
          if git ls-remote --exit-code --heads origin upstream-merge >/dev/null 2>&1; then
            if git merge-base --is-ancestor "upstream/${UPSTREAM_BRANCH}" "origin/upstream-merge" \
               && git merge-base --is-ancestor "origin/${DEFAULT_BRANCH}" "origin/upstream-merge"; then
              echo "skip=true" >> "$GITHUB_OUTPUT"
              echo "Upstream and default are already included in origin/upstream-merge; skipping agent run."
              exit 0
            fi
          fi
          if git merge-base --is-ancestor "upstream/${UPSTREAM_BRANCH}" "origin/${DEFAULT_BRANCH}"; then
            echo "skip=true" >> "$GITHUB_OUTPUT"
            echo "No new upstream commits; skipping agent run."
          else
            echo "skip=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Run Code agent to perform upstream merge
        id: agent
        if: steps.check_upstream.outputs.skip != 'true'
        env:
          UPSTREAM_REPO: ${{ env.UPSTREAM_REPO }}
          UPSTREAM_BRANCH: ${{ env.UPSTREAM_BRANCH }}
          MERGE_BRANCH: ${{ env.MERGE_BRANCH }}
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch || 'main' }}
          GH_TOKEN: ${{ secrets.CODE_GH_PAT || github.token }}
          OURS_GLOBS: |
            codex-rs/tui/**
            codex-cli/**
            .github/workflows/**
            AGENTS.md
            README.md
            CHANGELOG.md
          THEIRS_GLOBS: |
            codex-rs/core/**
            codex-rs/common/**
            codex-rs/protocol/**
            codex-rs/exec/**
            codex-rs/file-search/**
        run: |
          set -euo pipefail
          SAFE_PATH="$PATH"; SAFE_HOME="$HOME"
          # Build the agent prompt safely without command substitution
          {
            printf 'Context\n- UPSTREAM_REPO=%s\n- UPSTREAM_BRANCH=%s\n- MERGE_BRANCH=%s\n- DEFAULT_BRANCH=%s\n\n' \
              "$UPSTREAM_REPO" "$UPSTREAM_BRANCH" "$MERGE_BRANCH" "$DEFAULT_BRANCH";
            echo '<policy>';
            cat .github/merge-policy.json 2>/dev/null || echo '{ }';
            echo '</policy>';
            cat << 'EOP'
          <task>
          You are the maintainer bot. Perform an upstream merge using our repo policies and a selective reconciliation strategy.
          Steps:
          1) Configure git with author "just-every-code <just-every-code@users.noreply.github.com>".
          2) Ensure remote `upstream` points to the UPSTREAM_REPO in Context. Fetch origin and upstream.
          3) Re-create branch MERGE_BRANCH from origin/DEFAULT_BRANCH.
          4) Merge upstream/UPSTREAM_BRANCH using `--no-commit`.
             - Use the <policy> JSON for prefer_ours_globs and purge_globs (prefer_theirs_globs is intentionally empty).
             - Keep ours by default. Do NOT attempt to realign or reintroduce crates/dirs we removed locally.
             - For files matching prefer_ours_globs: keep ours; if upstream added new files under these globs that we donâ€™t have, prefer deletion.
             - For any path listed in purge_globs: ensure it remains deleted if upstream reintroduced it.
             - Only adopt upstream when the change is trivial and clearly safe (typos, comments) and outside protected areas; otherwise keep ours.
          5) Stage and commit with a conventional message and short build status.
          6) Run ./build-fast.sh (warnings treated as failures). Apply minimal safe fixes only.
          7) Write MERGE_REPORT.md (Incorporated / Dropped / Other changes) summarizing choices.
          8) Push MERGE_BRANCH and prepare PR title/body.
          </task>

          <constraints>
          - Be minimal and surgical; do not refactor.
          - Keep diffs focused on merge and required fixes. Do not recreate locally removed theming/UX files.
          - Never rewrite git history outside the merge branch.
          - Use only the provided GH_TOKEN for push; do not echo it.
          </constraints>
          EOP
          } | env -i PATH="$SAFE_PATH" HOME="$SAFE_HOME" \
            OPENAI_API_KEY="x" \
            OPENAI_BASE_URL="http://127.0.0.1:5055/v1" \
            OPENAI_API_BASE="http://127.0.0.1:5055/v1" \
            GH_TOKEN="$GH_TOKEN" \
            npm_config_cache="$SAFE_HOME/.npm" \
            npx -y @just-every/code@latest \
            exec \
            -s workspace-write \
            -c sandbox_workspace_write.allow_git_writes=true \
            -c sandbox_workspace_write.network_access=true \
            -c shell_environment_policy.r#set.CARGO_HOME="${RUNNER_TEMP}/cargo-home" \
            -c shell_environment_policy.r#set.CARGO_TARGET_DIR="${GITHUB_WORKSPACE}/codex-rs/target" \
            --cd "$GITHUB_WORKSPACE" \
            --skip-git-repo-check \
            - | tee .github/auto/AGENT_STDOUT.txt

      - name: Enforce policy removals on merge branch (images + caches + purge_globs)
        if: steps.check_upstream.outputs.skip != 'true'
        env:
          GH_TOKEN: ${{ secrets.CODE_GH_PAT || github.token }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          OWNER=${REPO%%/*}
          REPO_N=${REPO##*/}
          # Only proceed if branch exists
          if ! git ls-remote --exit-code --heads origin upstream-merge >/dev/null 2>&1; then
            echo "upstream-merge branch not found; skipping policy cleanup"; exit 0
          fi
          wt=.wt-upstream-merge-clean
          rm -rf "$wt" && git worktree add -f "$wt" origin/upstream-merge
          pushd "$wt" >/dev/null
          removed=false
          # Remove any tracked upstream images disallowed by local policy
          for p in .github/codex-cli-*.png .github/codex-cli-*.jpg .github/codex-cli-*.jpeg .github/codex-cli-*.webp; do
            files=$(git ls-files -- "$p" || true)
            if [ -n "$files" ]; then echo "$files" | xargs -r git rm -f --; removed=true; fi
          done
          # Belt-and-suspenders: drop any accidentally committed cargo cache dirs
          # Cover both repo-root and nested workspace (e.g., codex-rs/.cargo-home)
          for d in .cargo-home .cargo2 codex-rs/.cargo-home codex-rs/.cargo2; do
            files=$(git ls-files -- "$d/**" || true)
            if [ -n "$files" ]; then echo "$files" | xargs -r git rm -f --; removed=true; fi
          done
          # Drop any codex-rs/<crate> directories that do not exist on the default branch (we removed/renamed them locally)
          DEF_REF="origin/${DEFAULT_BRANCH}"
          # Collect crate dirs on default and on current worktree
          mapfile -t default_crates < <(git ls-tree -r --name-only "$DEF_REF" | awk -F'/' '/^codex-rs\//{print $1"/"$2}' | sort -u)
          mapfile -t branch_crates  < <(git ls-files | awk -F'/' '/^codex-rs\//{print $1"/"$2}' | sort -u)
          for c in "${branch_crates[@]}"; do
            keep=0
            for d in "${default_crates[@]}"; do [ "$c" = "$d" ] && keep=1 && break; done
            if [ $keep -eq 0 ]; then
              files=$(git ls-files -- "$c/**" || true)
              if [ -n "$files" ]; then echo "$files" | xargs -r git rm -f --; removed=true; fi
            fi
          done
          # Apply purge_globs and perma_removed_paths from merge-policy.json when present
          if command -v jq >/dev/null 2>&1 && [ -f ".github/merge-policy.json" ]; then
            mapfile -t purges < <(jq -r '.purge_globs[]? // empty' .github/merge-policy.json 2>/dev/null || true)
            mapfile -t perma  < <(jq -r '.perma_removed_paths[]? // empty' .github/merge-policy.json 2>/dev/null || true)
            for pat in "${purges[@]}" "${perma[@]}"; do
              [ -n "${pat:-}" ] || continue
              files=$(git ls-files -- "$pat" || true)
              if [ -n "$files" ]; then echo "$files" | xargs -r git rm -f --; removed=true; fi
            done
          fi
          if [ "$removed" = true ]; then
            git -c user.email="github-actions[bot]@users.noreply.github.com" -c user.name="github-actions[bot]" \
              commit -m "chore(merge): enforce policy removals (images + cargo caches)"
            git push origin HEAD:upstream-merge
          fi
          popd >/dev/null
          git worktree remove -f "$wt"
      
      - name: Policy guard checks (docs, branding, perma-deleted)
        if: steps.check_upstream.outputs.skip != 'true'
        env:
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch || 'main' }}
        run: |
          set -euo pipefail
          # Fail if docs/** changed between default and upstream-merge (we prefer ours)
          changed=$(git diff --name-only "origin/${DEFAULT_BRANCH}..origin/upstream-merge" -- 'docs/**' | wc -l | tr -d ' ')
          if [ "$changed" != "0" ]; then
            echo "docs/** changed on upstream-merge; policy prefers ours. Failing." >&2
            git diff --name-only "origin/${DEFAULT_BRANCH}..origin/upstream-merge" -- 'docs/**' >&2 || true
            exit 1
          fi
          # Branding guard: block additions of user-visible 'Codex' in TUI/CLI/docs (allow crate/package contexts)
          if git diff -U0 --no-color "origin/${DEFAULT_BRANCH}..origin/upstream-merge" -- codex-rs/tui/** codex-cli/** docs/** \
            | grep -E '^\+' \
            | grep -Ei '\bCodex\b' \
            | grep -Evi '(codex-rs|codex-[a-z0-9_-]+|https?://|Cargo|crate|package|workspace)' >/dev/null 2>&1; then
            echo "Branding guard tripped: new user-visible 'Codex' strings detected in TUI/CLI/docs." >&2
            git diff -U0 --no-color "origin/${DEFAULT_BRANCH}..origin/upstream-merge" -- codex-rs/tui/** codex-cli/** docs/** \
              | grep -E '^\+' | grep -Ei '\bCodex\b' | sed 's/^/> /' >&2 || true
            exit 1
          fi
          # Perma-deleted guard: ensure none of perma_removed_paths exist on branch
          if command -v jq >/dev/null 2>&1 && [ -f ".github/merge-policy.json" ]; then
            mapfile -t perma  < <(jq -r '.perma_removed_paths[]? // empty' .github/merge-policy.json 2>/dev/null || true)
            if [ ${#perma[@]} -gt 0 ]; then
              wt=.wt-guard
              rm -rf "$wt" && git worktree add -f "$wt" origin/upstream-merge >/dev/null
              pushd "$wt" >/dev/null
              for pat in "${perma[@]}"; do
                [ -n "${pat:-}" ] || continue
                if git ls-files -- "$pat" | grep -q .; then
                  echo "Perma-deleted guard: files present matching '$pat'" >&2
                  git ls-files -- "$pat" >&2 || true
                  exit 1
                fi
              done
              popd >/dev/null
              git worktree remove -f "$wt" >/dev/null
            fi
          fi

      - name: Open or update PR (use agent-supplied title/body if present)
        uses: actions/github-script@v7
        env:
          MERGE_BRANCH: ${{ env.MERGE_BRANCH }}
          UPSTREAM_REPO: ${{ env.UPSTREAM_REPO }}
          UPSTREAM_BRANCH: ${{ env.UPSTREAM_BRANCH }}
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch || 'main' }}
        with:
          github-token: ${{ secrets.CODE_GH_PAT || github.token }}
          script: |
            const fs = require('fs');
            function readOrDefault(p, dflt) { try { const t = fs.readFileSync(p,'utf8').trim(); return t || dflt; } catch { return dflt; } }
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const head = process.env.MERGE_BRANCH;
            const base = process.env.DEFAULT_BRANCH;
            const dfltTitle = `Upstream merge: ${process.env.UPSTREAM_REPO}@${process.env.UPSTREAM_BRANCH} into ${base}`;
            const title = readOrDefault('.github/auto/PR_TITLE.txt', dfltTitle);
            let body = readOrDefault('.github/auto/PR_BODY.md', '');
            if (!body) {
              body = `This PR merges ${process.env.UPSTREAM_REPO}@${process.env.UPSTREAM_BRANCH} into ${base}.`;
            }
            // Ensure the branch exists on origin before creating/updating a PR.
            const ref = `heads/${head}`;
            try {
              await github.rest.git.getRef({ owner, repo, ref });
            } catch (e) {
              core.notice(`Branch '${head}' not found on origin; skipping PR creation.`);
              return;
            }
            const headRef = `${owner}:${head}`;
            const prs = await github.rest.pulls.list({ owner, repo, state: 'open', head: headRef });
            if (prs.data.length) {
              const pr = prs.data[0];
              await github.rest.pulls.update({ owner, repo, pull_number: pr.number, title, body });
              core.notice(`Updated PR #${pr.number}`);
            } else {
              const pr = await github.rest.pulls.create({ owner, repo, title, head: headRef, base, body });
              core.notice(`Created PR #${pr.data.number}`);
            }
            // Ensure the branch exists on origin before creating/updating a PR.
            const ref = `heads/${head}`;
            try {
              await github.rest.git.getRef({ owner, repo, ref });
            } catch (e) {
              core.notice(`Branch '${head}' not found on origin; skipping PR creation.`);
              return;
            }
            const headRef = `${owner}:${head}`;
            const prs = await github.rest.pulls.list({ owner, repo, state: 'open', head: headRef });
            if (prs.data.length) {
              const pr = prs.data[0];
              await github.rest.pulls.update({ owner, repo, pull_number: pr.number, title, body });
              core.notice(`Updated PR #${pr.number}`);
            } else {
              const pr = await github.rest.pulls.create({ owner, repo, title, head: headRef, base, body });
              core.notice(`Created PR #${pr.data.number}`);
            }
