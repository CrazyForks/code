# Release workflow for codex-rs.
# To release, follow a workflow like:
# ```
# git tag -a rust-v0.1.0 -m "Release 0.1.0"
# git push origin rust-v0.1.0
# ```

name: rust-release
on:
  push:
    tags:
      - "rust-v*.*.*"

concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: true

jobs:
  tag-check:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.extract.outputs.version }}
    steps:
      - uses: actions/checkout@v5

      - name: Validate tag format and extract version
        id: extract
        shell: bash
        run: |
          set -euo pipefail
          echo "::group::Tag validation"

          # 1. Must be a tag and match the regex
          [[ "${GITHUB_REF_TYPE}" == "tag" ]] \
            || { echo "❌  Not a tag push"; exit 1; }
          [[ "${GITHUB_REF_NAME}" =~ ^rust-v[0-9]+\.[0-9]+\.[0-9]+(-(alpha|beta)(\.[0-9]+)?)?$ ]] \
            || { echo "❌  Tag '${GITHUB_REF_NAME}' doesn't match expected format"; exit 1; }

          # 2. Extract version from tag
          tag_ver="${GITHUB_REF_NAME#rust-v}"
          echo "version=${tag_ver}" >> $GITHUB_OUTPUT
          
          echo "✅  Tag format valid: ${GITHUB_REF_NAME}"
          echo "📦  Version to build: ${tag_ver}"
          echo "::endgroup::"

  build:
    needs: tag-check
    name: ${{ matrix.runner }} - ${{ matrix.target }}
    runs-on: ${{ matrix.runner }}
    timeout-minutes: 30
    defaults:
      run:
        working-directory: codex-rs

    strategy:
      fail-fast: false
      matrix:
        include:
          - runner: macos-14
            target: aarch64-apple-darwin
          - runner: macos-14
            target: x86_64-apple-darwin
          - runner: ubuntu-24.04
            target: x86_64-unknown-linux-musl
          - runner: ubuntu-24.04-arm
            target: aarch64-unknown-linux-musl
          - runner: windows-latest
            target: x86_64-pc-windows-msvc

    steps:
      - uses: actions/checkout@v4
      
      - name: Update version in Cargo.toml (workspace only)
        shell: bash
        run: |
          VERSION="${{ needs.tag-check.outputs.version }}"
          echo "📝 Updating version to ${VERSION} in Cargo.toml"
          
          # Update the workspace version
          sed -i.bak "s/^version = \".*\"/version = \"${VERSION}\"/" Cargo.toml
          
          # Verify the update
          echo "Updated Cargo.toml:"
          grep "^version = " Cargo.toml
          
          # Update Cargo.lock to reflect only workspace version bumps, without
          # floating third-party dependency versions or git revisions.
          echo "🔒 Updating Cargo.lock for workspace members only"
          # Extract member directories from [workspace] table (portable, no mapfile)
          awk '/^\s*\[workspace\]/{ws=1} ws && /^members\s*=\s*\[/{f=1; next} f && /\]/{f=0} f{ gsub(/[",]/,""); if($1!="") print $1 }' Cargo.toml \
            | while IFS= read -r dir; do
                if [[ -f "$dir/Cargo.toml" ]]; then
                  NAME=$(sed -n 's/^name\s*=\s*"\(.*\)"/\1/p' "$dir/Cargo.toml" | head -n1)
                  if [[ -n "$NAME" ]]; then
                    echo "  • cargo update -p $NAME"
                    cargo update -p "$NAME"
                  fi
                fi
              done
      
      - uses: dtolnay/rust-toolchain@1.89.0
        with:
          targets: ${{ matrix.target }}

      - name: Normalize Cargo.lock workspace versions
        shell: bash
        run: |
          set -euo pipefail
          VERSION="${{ needs.tag-check.outputs.version }}"
          echo "Ensuring Cargo.lock reflects workspace version ${VERSION}"
          # Build list of workspace crate names
          awk '/^\s*\[workspace\]/{ws=1} ws && /^members\s*=\s*\[/{f=1; next} f && /\]/{f=0} f{ gsub(/[",]/,""); if($1!="") print $1 }' Cargo.toml \
            | while IFS= read -r dir; do
                if [[ -f "$dir/Cargo.toml" ]]; then
                  sed -n 's/^name\s*=\s*"\(.*\)"/\1/p' "$dir/Cargo.toml"
                fi
              done \
            > .workspace-crate-names

          if [[ -s .workspace-crate-names ]]; then
            awk -v ver="$VERSION" 'FNR==NR { if ($0!="") want[$0]=1; next }
              /^\[\[package\]\]$/ { pkg=""; print; next }
              /^name = \"/ && pkg=="" { if (match($0, /^name = \"([^\"]+)\"/, m)) pkg=m[1]; print; next }
              /^version = \"/ {
                if (pkg != "" && (pkg in want)) { print "version = \"" ver "\"" } else { print }
                next
              }
              { print }
            ' .workspace-crate-names Cargo.lock > Cargo.lock.tmp && mv Cargo.lock.tmp Cargo.lock
          fi
          rm -f .workspace-crate-names

      # Smart caching for Rust builds - handles everything automatically
      - name: Setup Rust Cache
        uses: Swatinem/rust-cache@v2
        with:
          # Ensure cache is unique per target
          key: ${{ matrix.target }}
          # Cache on failure to speed up debugging
          cache-on-failure: true
          # Working directory for the cache
          workspaces: "codex-rs -> target"

      - if: ${{ matrix.target == 'x86_64-unknown-linux-musl' || matrix.target == 'aarch64-unknown-linux-musl'}}
        name: Install musl build tools
        run: |
          sudo apt install -y musl-tools pkg-config

      - name: Cargo build
        shell: bash
        run: |
          # Use all available cores
          if [[ "${{ matrix.runner }}" == windows* ]]; then
            # Windows: Use NUMBER_OF_PROCESSORS env var
            export CARGO_BUILD_JOBS=$((${NUMBER_OF_PROCESSORS:-2} * 2))
          else
            # Unix-like: Prefer nproc if available, otherwise getconf/sysctl
            CORES=$((
              $( (command -v nproc >/dev/null 2>&1 && nproc) \
                 || (getconf _NPROCESSORS_ONLN 2>/dev/null) \
                 || (sysctl -n hw.ncpu 2>/dev/null) \
                 || echo 2 )
            ))
            export CARGO_BUILD_JOBS=$((CORES * 2))
          fi
          echo "Building with $CARGO_BUILD_JOBS parallel jobs"
          # Use --locked to ensure reproducible builds
          # Build the renamed binaries (code, code-tui, code-exec)
          cargo build --target ${{ matrix.target }} --release --locked --bin code --bin code-tui --bin code-exec

      - name: Stage artifacts
        shell: bash
        run: |
          dest="dist/${{ matrix.target }}"
          mkdir -p "$dest"

          if [[ "${{ matrix.runner }}" == windows* ]]; then
            cp target/${{ matrix.target }}/release/code.exe "$dest/code-${{ matrix.target }}.exe"
            cp target/${{ matrix.target }}/release/code-tui.exe "$dest/code-tui-${{ matrix.target }}.exe"
            cp target/${{ matrix.target }}/release/code-exec.exe "$dest/code-exec-${{ matrix.target }}.exe"
          else
            cp target/${{ matrix.target }}/release/code "$dest/code-${{ matrix.target }}"
            cp target/${{ matrix.target }}/release/code-tui "$dest/code-tui-${{ matrix.target }}"
            cp target/${{ matrix.target }}/release/code-exec "$dest/code-exec-${{ matrix.target }}"
          fi

      - name: Compress artifacts
        shell: bash
        run: |
          # Path that contains the uncompressed binaries for the current
          # ${{ matrix.target }}
          dest="dist/${{ matrix.target }}"

          # Use single format per OS:
          # - Linux/macOS: .zst (smaller, well-supported)
          # - Windows: .zip (standard for Windows)

          for f in "$dest"/*; do
            base="$(basename "$f")"
            # Skip files that are already archives
            if [[ "$base" == *.tar.gz || "$base" == *.zip || "$base" == *.zst ]]; then
              continue
            fi

            if [[ "${{ matrix.runner }}" == windows* ]]; then
              # Windows: Create only .zip
              (cd "$dest" && 7z a "${base}.zip" "$base")
              rm "$dest/$base"
            else
              # Linux/macOS: Create only .zst
              zstd -T0 -19 --rm "$dest/$base"
            fi
          done

      - uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.target }}
          # Upload the per-binary .zst files as well as the new .tar.gz
          # equivalents we generated in the previous step.
          path: |
            codex-rs/dist/${{ matrix.target }}/*

  release:
    needs: build
    name: release
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - uses: actions/download-artifact@v4
        with:
          path: dist

      - name: List
        run: ls -R dist/

      - name: Define release name
        id: release_name
        run: |
          # Extract the version from the tag name, which is in the format
          # "rust-v0.1.0".
          version="${GITHUB_REF_NAME#rust-v}"
          echo "name=${version}" >> $GITHUB_OUTPUT

      - name: Stage npm package
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          TMP_DIR="${RUNNER_TEMP}/npm-stage"
          python3 codex-cli/scripts/stage_rust_release.py \
            --release-version "${{ steps.release_name.outputs.name }}" \
            --tmp "${TMP_DIR}"
          mkdir -p dist/npm
          # Produce an npm-ready tarball using `npm pack` and store it in dist/npm.
          # We then rename it to a stable name used by our publishing script.
          (cd "$TMP_DIR" && npm pack --pack-destination "${GITHUB_WORKSPACE}/dist/npm")
          mv "${GITHUB_WORKSPACE}"/dist/npm/*.tgz \
             "${GITHUB_WORKSPACE}/dist/npm/codex-npm-${{ steps.release_name.outputs.name }}.tgz"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          name: ${{ steps.release_name.outputs.name }}
          tag_name: ${{ github.ref_name }}
          files: dist/**
          # Mark as prerelease only when the version has a suffix after x.y.z
          # (e.g. -alpha, -beta). Otherwise publish a normal release.
          prerelease: ${{ contains(steps.release_name.outputs.name, '-') }}

      - uses: facebook/dotslash-publish-release@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag: ${{ github.ref_name }}
          config: .github/dotslash-config.json
